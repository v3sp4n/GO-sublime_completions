{
    "scope":"source.go",
    "completions":[
        {
            "trigger":"os.Chdir",
            "contents":"os.Chdir(${1:dir string})",
            "details":"return  error",
            "annotation":"(dir string)"
        },
        {
            "trigger":"os.Chmod",
            "contents":"os.Chmod(${1:name string, mode FileMode})",
            "details":"return  error",
            "annotation":"(name string, mode FileMode)"
        },
        {
            "trigger":"os.Chown",
            "contents":"os.Chown(${1:name string, uid, gid int})",
            "details":"return  error",
            "annotation":"(name string, uid, gid int)"
        },
        {
            "trigger":"os.Chtimes",
            "contents":"os.Chtimes(${1:name string, atime time.Time, mtime time.Time})",
            "details":"return  error",
            "annotation":"(name string, atime time.Time, mtime time.Time)"
        },
        {
            "trigger":"os.Clearenv",
            "contents":"os.Clearenv()",
            "details":"return ",
            "annotation":"()"
        },
        {
            "trigger":"os.DirFS",
            "contents":"os.DirFS(${1:dir string})",
            "details":"return  fs.FS",
            "annotation":"(dir string)"
        },
        {
            "trigger":"os.Environ",
            "contents":"os.Environ()",
            "details":"return  []string",
            "annotation":"()"
        },
        {
            "trigger":"os.Executable",
            "contents":"os.Executable()",
            "details":"return  (string, error)",
            "annotation":"()"
        },
        {
            "trigger":"os.Exit",
            "contents":"os.Exit(${1:code int})",
            "details":"return ",
            "annotation":"(code int)"
        },
        {
            "trigger":"os.Expand",
            "contents":"os.Expand(${1:s string, mapping func(string})",
            "details":"return  string) string",
            "annotation":"(s string, mapping func(string)"
        },
        {
            "trigger":"os.ExpandEnv",
            "contents":"os.ExpandEnv(${1:s string})",
            "details":"return  string",
            "annotation":"(s string)"
        },
        {
            "trigger":"os.Getegid",
            "contents":"os.Getegid()",
            "details":"return  int",
            "annotation":"()"
        },
        {
            "trigger":"os.Getenv",
            "contents":"os.Getenv(${1:key string})",
            "details":"return  string",
            "annotation":"(key string)"
        },
        {
            "trigger":"os.Geteuid",
            "contents":"os.Geteuid()",
            "details":"return  int",
            "annotation":"()"
        },
        {
            "trigger":"os.Getgid",
            "contents":"os.Getgid()",
            "details":"return  int",
            "annotation":"()"
        },
        {
            "trigger":"os.Getgroups",
            "contents":"os.Getgroups()",
            "details":"return  ([]int, error)",
            "annotation":"()"
        },
        {
            "trigger":"os.Getpagesize",
            "contents":"os.Getpagesize()",
            "details":"return  int",
            "annotation":"()"
        },
        {
            "trigger":"os.Getpid",
            "contents":"os.Getpid()",
            "details":"return  int",
            "annotation":"()"
        },
        {
            "trigger":"os.Getppid",
            "contents":"os.Getppid()",
            "details":"return  int",
            "annotation":"()"
        },
        {
            "trigger":"os.Getuid",
            "contents":"os.Getuid()",
            "details":"return  int",
            "annotation":"()"
        },
        {
            "trigger":"os.Getwd",
            "contents":"os.Getwd()",
            "details":"return  (dir string, err error)",
            "annotation":"()"
        },
        {
            "trigger":"os.Hostname",
            "contents":"os.Hostname()",
            "details":"return  (name string, err error)",
            "annotation":"()"
        },
        {
            "trigger":"os.IsExist",
            "contents":"os.IsExist(${1:err error})",
            "details":"return  bool",
            "annotation":"(err error)"
        },
        {
            "trigger":"os.IsNotExist",
            "contents":"os.IsNotExist(${1:err error})",
            "details":"return  bool",
            "annotation":"(err error)"
        },
        {
            "trigger":"os.IsPathSeparator",
            "contents":"os.IsPathSeparator(${1:c uint8})",
            "details":"return  bool",
            "annotation":"(c uint8)"
        },
        {
            "trigger":"os.IsPermission",
            "contents":"os.IsPermission(${1:err error})",
            "details":"return  bool",
            "annotation":"(err error)"
        },
        {
            "trigger":"os.IsTimeout",
            "contents":"os.IsTimeout(${1:err error})",
            "details":"return  bool",
            "annotation":"(err error)"
        },
        {
            "trigger":"os.Lchown",
            "contents":"os.Lchown(${1:name string, uid, gid int})",
            "details":"return  error",
            "annotation":"(name string, uid, gid int)"
        },
        {
            "trigger":"os.Link",
            "contents":"os.Link(${1:oldname, newname string})",
            "details":"return  error",
            "annotation":"(oldname, newname string)"
        },
        {
            "trigger":"os.LookupEnv",
            "contents":"os.LookupEnv(${1:key string})",
            "details":"return  (string, bool)",
            "annotation":"(key string)"
        },
        {
            "trigger":"os.Mkdir",
            "contents":"os.Mkdir(${1:name string, perm FileMode})",
            "details":"return  error",
            "annotation":"(name string, perm FileMode)"
        },
        {
            "trigger":"os.MkdirAll",
            "contents":"os.MkdirAll(${1:path string, perm FileMode})",
            "details":"return  error",
            "annotation":"(path string, perm FileMode)"
        },
        {
            "trigger":"os.MkdirTemp",
            "contents":"os.MkdirTemp(${1:dir, pattern string})",
            "details":"return  (string, error)",
            "annotation":"(dir, pattern string)"
        },
        {
            "trigger":"os.NewSyscallError",
            "contents":"os.NewSyscallError(${1:syscall string, err error})",
            "details":"return  error",
            "annotation":"(syscall string, err error)"
        },
        {
            "trigger":"os.Pipe",
            "contents":"os.Pipe()",
            "details":"return  (r *File, w *File, err error)",
            "annotation":"()"
        },
        {
            "trigger":"os.ReadFile",
            "contents":"os.ReadFile(${1:name string})",
            "details":"return  ([]byte, error)",
            "annotation":"(name string)"
        },
        {
            "trigger":"os.Readlink",
            "contents":"os.Readlink(${1:name string})",
            "details":"return  (string, error)",
            "annotation":"(name string)"
        },
        {
            "trigger":"os.Remove",
            "contents":"os.Remove(${1:name string})",
            "details":"return  error",
            "annotation":"(name string)"
        },
        {
            "trigger":"os.RemoveAll",
            "contents":"os.RemoveAll(${1:path string})",
            "details":"return  error",
            "annotation":"(path string)"
        },
        {
            "trigger":"os.Rename",
            "contents":"os.Rename(${1:oldpath, newpath string})",
            "details":"return  error",
            "annotation":"(oldpath, newpath string)"
        },
        {
            "trigger":"os.SameFile",
            "contents":"os.SameFile(${1:fi1, fi2 FileInfo})",
            "details":"return  bool",
            "annotation":"(fi1, fi2 FileInfo)"
        },
        {
            "trigger":"os.Setenv",
            "contents":"os.Setenv(${1:key, value string})",
            "details":"return  error",
            "annotation":"(key, value string)"
        },
        {
            "trigger":"os.Symlink",
            "contents":"os.Symlink(${1:oldname, newname string})",
            "details":"return  error",
            "annotation":"(oldname, newname string)"
        },
        {
            "trigger":"os.TempDir",
            "contents":"os.TempDir()",
            "details":"return  string",
            "annotation":"()"
        },
        {
            "trigger":"os.Truncate",
            "contents":"os.Truncate(${1:name string, size int64})",
            "details":"return  error",
            "annotation":"(name string, size int64)"
        },
        {
            "trigger":"os.Unsetenv",
            "contents":"os.Unsetenv(${1:key string})",
            "details":"return  error",
            "annotation":"(key string)"
        },
        {
            "trigger":"os.UserCacheDir",
            "contents":"os.UserCacheDir()",
            "details":"return  (string, error)",
            "annotation":"()"
        },
        {
            "trigger":"os.UserConfigDir",
            "contents":"os.UserConfigDir()",
            "details":"return  (string, error)",
            "annotation":"()"
        },
        {
            "trigger":"os.UserHomeDir",
            "contents":"os.UserHomeDir()",
            "details":"return  (string, error)",
            "annotation":"()"
        },
        {
            "trigger":"os.WriteFile",
            "contents":"os.WriteFile(${1:name string, data []byte, perm FileMode})",
            "details":"return  error",
            "annotation":"(name string, data []byte, perm FileMode)"
        },
        {
            "trigger":"os.ReadDir",
            "contents":"os.ReadDir(${1:name string})",
            "details":"return  ([]DirEntry, error)",
            "annotation":"(name string)"
        },
        {
            "trigger":"os.Create",
            "contents":"os.Create(${1:name string})",
            "details":"return  (*File, error)",
            "annotation":"(name string)"
        },
        {
            "trigger":"os.CreateTemp",
            "contents":"os.CreateTemp(${1:dir, pattern string})",
            "details":"return  (*File, error)",
            "annotation":"(dir, pattern string)"
        },
        {
            "trigger":"os.NewFile",
            "contents":"os.NewFile(${1:fd uintptr, name string})",
            "details":"return  *File",
            "annotation":"(fd uintptr, name string)"
        },
        {
            "trigger":"os.Open",
            "contents":"os.Open(${1:name string})",
            "details":"return  (*File, error)",
            "annotation":"(name string)"
        },
        {
            "trigger":"os.OpenFile",
            "contents":"os.OpenFile(${1:name string, flag int, perm FileMode})",
            "details":"return  (*File, error)",
            "annotation":"(name string, flag int, perm FileMode)"
        },
        {
            "trigger":"os.Lstat",
            "contents":"os.Lstat(${1:name string})",
            "details":"return  (FileInfo, error)",
            "annotation":"(name string)"
        },
        {
            "trigger":"os.Stat",
            "contents":"os.Stat(${1:name string})",
            "details":"return  (FileInfo, error)",
            "annotation":"(name string)"
        },
        {
            "trigger":"os.FindProcess",
            "contents":"os.FindProcess(${1:pid int})",
            "details":"return  (*Process, error)",
            "annotation":"(pid int)"
        },
        {
            "trigger":"os.StartProcess",
            "contents":"os.StartProcess(${1:name string, argv []string, attr *ProcAttr})",
            "details":"return  (*Process, error)",
            "annotation":"(name string, argv []string, attr *ProcAttr)"
        },
        {
            "trigger":"fmt.Append",
            "contents":"fmt.Append(${1:b []byte, a ...any})",
            "details":"return  []byte",
            "annotation":"(b []byte, a ...any)"
        },
        {
            "trigger":"fmt.Appendf",
            "contents":"fmt.Appendf(${1:b []byte, format string, a ...any})",
            "details":"return  []byte",
            "annotation":"(b []byte, format string, a ...any)"
        },
        {
            "trigger":"fmt.Appendln",
            "contents":"fmt.Appendln(${1:b []byte, a ...any})",
            "details":"return  []byte",
            "annotation":"(b []byte, a ...any)"
        },
        {
            "trigger":"fmt.Errorf",
            "contents":"fmt.Errorf(${1:format string, a ...any})",
            "details":"return  error",
            "annotation":"(format string, a ...any)"
        },
        {
            "trigger":"fmt.FormatString",
            "contents":"fmt.FormatString(${1:state State, verb rune})",
            "details":"return  string",
            "annotation":"(state State, verb rune)"
        },
        {
            "trigger":"fmt.Fprint",
            "contents":"fmt.Fprint(${1:w io.Writer, a ...any})",
            "details":"return  (n int, err error)",
            "annotation":"(w io.Writer, a ...any)"
        },
        {
            "trigger":"fmt.Fprintf",
            "contents":"fmt.Fprintf(${1:w io.Writer, format string, a ...any})",
            "details":"return  (n int, err error)",
            "annotation":"(w io.Writer, format string, a ...any)"
        },
        {
            "trigger":"fmt.Fprintln",
            "contents":"fmt.Fprintln(${1:w io.Writer, a ...any})",
            "details":"return  (n int, err error)",
            "annotation":"(w io.Writer, a ...any)"
        },
        {
            "trigger":"fmt.Fscan",
            "contents":"fmt.Fscan(${1:r io.Reader, a ...any})",
            "details":"return  (n int, err error)",
            "annotation":"(r io.Reader, a ...any)"
        },
        {
            "trigger":"fmt.Fscanf",
            "contents":"fmt.Fscanf(${1:r io.Reader, format string, a ...any})",
            "details":"return  (n int, err error)",
            "annotation":"(r io.Reader, format string, a ...any)"
        },
        {
            "trigger":"fmt.Fscanln",
            "contents":"fmt.Fscanln(${1:r io.Reader, a ...any})",
            "details":"return  (n int, err error)",
            "annotation":"(r io.Reader, a ...any)"
        },
        {
            "trigger":"fmt.Print",
            "contents":"fmt.Print(${1:a ...any})",
            "details":"return  (n int, err error)",
            "annotation":"(a ...any)"
        },
        {
            "trigger":"fmt.Printf",
            "contents":"fmt.Printf(${1:format string, a ...any})",
            "details":"return  (n int, err error)",
            "annotation":"(format string, a ...any)"
        },
        {
            "trigger":"fmt.Println",
            "contents":"fmt.Println(${1:a ...any})",
            "details":"return  (n int, err error)",
            "annotation":"(a ...any)"
        },
        {
            "trigger":"fmt.Scan",
            "contents":"fmt.Scan(${1:a ...any})",
            "details":"return  (n int, err error)",
            "annotation":"(a ...any)"
        },
        {
            "trigger":"fmt.Scanf",
            "contents":"fmt.Scanf(${1:format string, a ...any})",
            "details":"return  (n int, err error)",
            "annotation":"(format string, a ...any)"
        },
        {
            "trigger":"fmt.Scanln",
            "contents":"fmt.Scanln(${1:a ...any})",
            "details":"return  (n int, err error)",
            "annotation":"(a ...any)"
        },
        {
            "trigger":"fmt.Sprint",
            "contents":"fmt.Sprint(${1:a ...any})",
            "details":"return  string",
            "annotation":"(a ...any)"
        },
        {
            "trigger":"fmt.Sprintf",
            "contents":"fmt.Sprintf(${1:format string, a ...any})",
            "details":"return  string",
            "annotation":"(format string, a ...any)"
        },
        {
            "trigger":"fmt.Sprintln",
            "contents":"fmt.Sprintln(${1:a ...any})",
            "details":"return  string",
            "annotation":"(a ...any)"
        },
        {
            "trigger":"fmt.Sscan",
            "contents":"fmt.Sscan(${1:str string, a ...any})",
            "details":"return  (n int, err error)",
            "annotation":"(str string, a ...any)"
        },
        {
            "trigger":"fmt.Sscanf",
            "contents":"fmt.Sscanf(${1:str string, format string, a ...any})",
            "details":"return  (n int, err error)",
            "annotation":"(str string, format string, a ...any)"
        },
        {
            "trigger":"fmt.Sscanln",
            "contents":"fmt.Sscanln(${1:str string, a ...any})",
            "details":"return  (n int, err error)",
            "annotation":"(str string, a ...any)"
        },
        {
            "trigger":"math.Abs",
            "contents":"math.Abs(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Acos",
            "contents":"math.Acos(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Acosh",
            "contents":"math.Acosh(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Asin",
            "contents":"math.Asin(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Asinh",
            "contents":"math.Asinh(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Atan",
            "contents":"math.Atan(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Atan2",
            "contents":"math.Atan2(${1:y, x float64})",
            "details":"return  float64",
            "annotation":"(y, x float64)"
        },
        {
            "trigger":"math.Atanh",
            "contents":"math.Atanh(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Cbrt",
            "contents":"math.Cbrt(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Ceil",
            "contents":"math.Ceil(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Copysign",
            "contents":"math.Copysign(${1:f, sign float64})",
            "details":"return  float64",
            "annotation":"(f, sign float64)"
        },
        {
            "trigger":"math.Cos",
            "contents":"math.Cos(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Cosh",
            "contents":"math.Cosh(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Dim",
            "contents":"math.Dim(${1:x, y float64})",
            "details":"return  float64",
            "annotation":"(x, y float64)"
        },
        {
            "trigger":"math.Erf",
            "contents":"math.Erf(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Erfc",
            "contents":"math.Erfc(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Erfcinv",
            "contents":"math.Erfcinv(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Erfinv",
            "contents":"math.Erfinv(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Exp",
            "contents":"math.Exp(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Exp2",
            "contents":"math.Exp2(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Expm1",
            "contents":"math.Expm1(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.FMA",
            "contents":"math.FMA(${1:x, y, z float64})",
            "details":"return  float64",
            "annotation":"(x, y, z float64)"
        },
        {
            "trigger":"math.Float32bits",
            "contents":"math.Float32bits(${1:f float32})",
            "details":"return  uint32",
            "annotation":"(f float32)"
        },
        {
            "trigger":"math.Float32frombits",
            "contents":"math.Float32frombits(${1:b uint32})",
            "details":"return  float32",
            "annotation":"(b uint32)"
        },
        {
            "trigger":"math.Float64bits",
            "contents":"math.Float64bits(${1:f float64})",
            "details":"return  uint64",
            "annotation":"(f float64)"
        },
        {
            "trigger":"math.Float64frombits",
            "contents":"math.Float64frombits(${1:b uint64})",
            "details":"return  float64",
            "annotation":"(b uint64)"
        },
        {
            "trigger":"math.Floor",
            "contents":"math.Floor(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Frexp",
            "contents":"math.Frexp(${1:f float64})",
            "details":"return  (frac float64, exp int)",
            "annotation":"(f float64)"
        },
        {
            "trigger":"math.Gamma",
            "contents":"math.Gamma(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Hypot",
            "contents":"math.Hypot(${1:p, q float64})",
            "details":"return  float64",
            "annotation":"(p, q float64)"
        },
        {
            "trigger":"math.Ilogb",
            "contents":"math.Ilogb(${1:x float64})",
            "details":"return  int",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Inf",
            "contents":"math.Inf(${1:sign int})",
            "details":"return  float64",
            "annotation":"(sign int)"
        },
        {
            "trigger":"math.IsInf",
            "contents":"math.IsInf(${1:f float64, sign int})",
            "details":"return  bool",
            "annotation":"(f float64, sign int)"
        },
        {
            "trigger":"math.IsNaN",
            "contents":"math.IsNaN(${1:f float64})",
            "details":"return  (is bool)",
            "annotation":"(f float64)"
        },
        {
            "trigger":"math.J0",
            "contents":"math.J0(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.J1",
            "contents":"math.J1(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Jn",
            "contents":"math.Jn(${1:n int, x float64})",
            "details":"return  float64",
            "annotation":"(n int, x float64)"
        },
        {
            "trigger":"math.Ldexp",
            "contents":"math.Ldexp(${1:frac float64, exp int})",
            "details":"return  float64",
            "annotation":"(frac float64, exp int)"
        },
        {
            "trigger":"math.Lgamma",
            "contents":"math.Lgamma(${1:x float64})",
            "details":"return  (lgamma float64, sign int)",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Log",
            "contents":"math.Log(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Log10",
            "contents":"math.Log10(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Log1p",
            "contents":"math.Log1p(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Log2",
            "contents":"math.Log2(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Logb",
            "contents":"math.Logb(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Max",
            "contents":"math.Max(${1:x, y float64})",
            "details":"return  float64",
            "annotation":"(x, y float64)"
        },
        {
            "trigger":"math.Min",
            "contents":"math.Min(${1:x, y float64})",
            "details":"return  float64",
            "annotation":"(x, y float64)"
        },
        {
            "trigger":"math.Mod",
            "contents":"math.Mod(${1:x, y float64})",
            "details":"return  float64",
            "annotation":"(x, y float64)"
        },
        {
            "trigger":"math.Modf",
            "contents":"math.Modf(${1:f float64})",
            "details":"return  (int float64, frac float64)",
            "annotation":"(f float64)"
        },
        {
            "trigger":"math.NaN",
            "contents":"math.NaN()",
            "details":"return  float64",
            "annotation":"()"
        },
        {
            "trigger":"math.Nextafter",
            "contents":"math.Nextafter(${1:x, y float64})",
            "details":"return  (r float64)",
            "annotation":"(x, y float64)"
        },
        {
            "trigger":"math.Nextafter32",
            "contents":"math.Nextafter32(${1:x, y float32})",
            "details":"return  (r float32)",
            "annotation":"(x, y float32)"
        },
        {
            "trigger":"math.Pow",
            "contents":"math.Pow(${1:x, y float64})",
            "details":"return  float64",
            "annotation":"(x, y float64)"
        },
        {
            "trigger":"math.Pow10",
            "contents":"math.Pow10(${1:n int})",
            "details":"return  float64",
            "annotation":"(n int)"
        },
        {
            "trigger":"math.Remainder",
            "contents":"math.Remainder(${1:x, y float64})",
            "details":"return  float64",
            "annotation":"(x, y float64)"
        },
        {
            "trigger":"math.Round",
            "contents":"math.Round(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.RoundToEven",
            "contents":"math.RoundToEven(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Signbit",
            "contents":"math.Signbit(${1:x float64})",
            "details":"return  bool",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Sin",
            "contents":"math.Sin(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Sincos",
            "contents":"math.Sincos(${1:x float64})",
            "details":"return  (sin, cos float64)",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Sinh",
            "contents":"math.Sinh(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Sqrt",
            "contents":"math.Sqrt(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Tan",
            "contents":"math.Tan(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Tanh",
            "contents":"math.Tanh(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Trunc",
            "contents":"math.Trunc(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Y0",
            "contents":"math.Y0(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Y1",
            "contents":"math.Y1(${1:x float64})",
            "details":"return  float64",
            "annotation":"(x float64)"
        },
        {
            "trigger":"math.Yn",
            "contents":"math.Yn(${1:n int, x float64})",
            "details":"return  float64",
            "annotation":"(n int, x float64)"
        },
        {
            "trigger":"time.After",
            "contents":"time.After(${1:d Duration})",
            "details":"return  &lt;-chan Time",
            "annotation":"(d Duration)"
        },
        {
            "trigger":"time.Sleep",
            "contents":"time.Sleep(${1:d Duration})",
            "details":"return ",
            "annotation":"(d Duration)"
        },
        {
            "trigger":"time.Tick",
            "contents":"time.Tick(${1:d Duration})",
            "details":"return  &lt;-chan Time",
            "annotation":"(d Duration)"
        },
        {
            "trigger":"time.ParseDuration",
            "contents":"time.ParseDuration(${1:s string})",
            "details":"return  (Duration, error)",
            "annotation":"(s string)"
        },
        {
            "trigger":"time.Since",
            "contents":"time.Since(${1:t Time})",
            "details":"return  Duration",
            "annotation":"(t Time)"
        },
        {
            "trigger":"time.Until",
            "contents":"time.Until(${1:t Time})",
            "details":"return  Duration",
            "annotation":"(t Time)"
        },
        {
            "trigger":"time.FixedZone",
            "contents":"time.FixedZone(${1:name string, offset int})",
            "details":"return  *Location",
            "annotation":"(name string, offset int)"
        },
        {
            "trigger":"time.LoadLocation",
            "contents":"time.LoadLocation(${1:name string})",
            "details":"return  (*Location, error)",
            "annotation":"(name string)"
        },
        {
            "trigger":"time.LoadLocationFromTZData",
            "contents":"time.LoadLocationFromTZData(${1:name string, data []byte})",
            "details":"return  (*Location, error)",
            "annotation":"(name string, data []byte)"
        },
        {
            "trigger":"time.NewTicker",
            "contents":"time.NewTicker(${1:d Duration})",
            "details":"return  *Ticker",
            "annotation":"(d Duration)"
        },
        {
            "trigger":"time.Date",
            "contents":"time.Date(${1:year int, month Month, day, hour, min, sec, nsec int, loc *Location})",
            "details":"return  Time",
            "annotation":"(year int, month Month, day, hour, min, sec, nsec int, loc *Location)"
        },
        {
            "trigger":"time.Now",
            "contents":"time.Now()",
            "details":"return  Time",
            "annotation":"()"
        },
        {
            "trigger":"time.Parse",
            "contents":"time.Parse(${1:layout, value string})",
            "details":"return  (Time, error)",
            "annotation":"(layout, value string)"
        },
        {
            "trigger":"time.ParseInLocation",
            "contents":"time.ParseInLocation(${1:layout, value string, loc *Location})",
            "details":"return  (Time, error)",
            "annotation":"(layout, value string, loc *Location)"
        },
        {
            "trigger":"time.Unix",
            "contents":"time.Unix(${1:sec int64, nsec int64})",
            "details":"return  Time",
            "annotation":"(sec int64, nsec int64)"
        },
        {
            "trigger":"time.UnixMicro",
            "contents":"time.UnixMicro(${1:usec int64})",
            "details":"return  Time",
            "annotation":"(usec int64)"
        },
        {
            "trigger":"time.UnixMilli",
            "contents":"time.UnixMilli(${1:msec int64})",
            "details":"return  Time",
            "annotation":"(msec int64)"
        },
        {
            "trigger":"time.AfterFunc",
            "contents":"time.AfterFunc(${1:d Duration, f func(})",
            "details":"return ) *Timer",
            "annotation":"(d Duration, f func()"
        },
        {
            "trigger":"time.NewTimer",
            "contents":"time.NewTimer(${1:d Duration})",
            "details":"return  *Timer",
            "annotation":"(d Duration)"
        },
        {
            "trigger":"ioutil.NopCloser",
            "contents":"ioutil.NopCloser(${1:r io.Reader})",
            "details":"return  io.ReadCloser",
            "annotation":"(r io.Reader)"
        },
        {
            "trigger":"ioutil.ReadAll",
            "contents":"ioutil.ReadAll(${1:r io.Reader})",
            "details":"return  ([]byte, error)",
            "annotation":"(r io.Reader)"
        },
        {
            "trigger":"ioutil.ReadDir",
            "contents":"ioutil.ReadDir(${1:dirname string})",
            "details":"return  ([]fs.FileInfo, error)",
            "annotation":"(dirname string)"
        },
        {
            "trigger":"ioutil.ReadFile",
            "contents":"ioutil.ReadFile(${1:filename string})",
            "details":"return  ([]byte, error)",
            "annotation":"(filename string)"
        },
        {
            "trigger":"ioutil.TempDir",
            "contents":"ioutil.TempDir(${1:dir, pattern string})",
            "details":"return  (name string, err error)",
            "annotation":"(dir, pattern string)"
        },
        {
            "trigger":"ioutil.TempFile",
            "contents":"ioutil.TempFile(${1:dir, pattern string})",
            "details":"return  (f *os.File, err error)",
            "annotation":"(dir, pattern string)"
        },
        {
            "trigger":"ioutil.WriteFile",
            "contents":"ioutil.WriteFile(${1:filename string, data []byte, perm fs.FileMode})",
            "details":"return  error",
            "annotation":"(filename string, data []byte, perm fs.FileMode)"
        },
        {
            "trigger":"rand.ExpFloat64",
            "contents":"rand.ExpFloat64()",
            "details":"return  float64",
            "annotation":"()"
        },
        {
            "trigger":"rand.Float32",
            "contents":"rand.Float32()",
            "details":"return  float32",
            "annotation":"()"
        },
        {
            "trigger":"rand.Float64",
            "contents":"rand.Float64()",
            "details":"return  float64",
            "annotation":"()"
        },
        {
            "trigger":"rand.Int",
            "contents":"rand.Int()",
            "details":"return  int",
            "annotation":"()"
        },
        {
            "trigger":"rand.Int31",
            "contents":"rand.Int31()",
            "details":"return  int32",
            "annotation":"()"
        },
        {
            "trigger":"rand.Int31n",
            "contents":"rand.Int31n(${1:n int32})",
            "details":"return  int32",
            "annotation":"(n int32)"
        },
        {
            "trigger":"rand.Int63",
            "contents":"rand.Int63()",
            "details":"return  int64",
            "annotation":"()"
        },
        {
            "trigger":"rand.Int63n",
            "contents":"rand.Int63n(${1:n int64})",
            "details":"return  int64",
            "annotation":"(n int64)"
        },
        {
            "trigger":"rand.Intn",
            "contents":"rand.Intn(${1:n int})",
            "details":"return  int",
            "annotation":"(n int)"
        },
        {
            "trigger":"rand.NormFloat64",
            "contents":"rand.NormFloat64()",
            "details":"return  float64",
            "annotation":"()"
        },
        {
            "trigger":"rand.Perm",
            "contents":"rand.Perm(${1:n int})",
            "details":"return  []int",
            "annotation":"(n int)"
        },
        {
            "trigger":"rand.Read",
            "contents":"rand.Read(${1:p []byte})",
            "details":"return  (n int, err error)",
            "annotation":"(p []byte)"
        },
        {
            "trigger":"rand.Seed",
            "contents":"rand.Seed(${1:seed int64})",
            "details":"return ",
            "annotation":"(seed int64)"
        },
        {
            "trigger":"rand.Shuffle",
            "contents":"rand.Shuffle(${1:n int, swap func(i, j int})",
            "details":"return )",
            "annotation":"(n int, swap func(i, j int)"
        },
        {
            "trigger":"rand.Uint32",
            "contents":"rand.Uint32()",
            "details":"return  uint32",
            "annotation":"()"
        },
        {
            "trigger":"rand.Uint64",
            "contents":"rand.Uint64()",
            "details":"return  uint64",
            "annotation":"()"
        },
        {
            "trigger":"rand.New",
            "contents":"rand.New(${1:src Source})",
            "details":"return  *Rand",
            "annotation":"(src Source)"
        },
        {
            "trigger":"rand.NewSource",
            "contents":"rand.NewSource(${1:seed int64})",
            "details":"return  Source",
            "annotation":"(seed int64)"
        },
        {
            "trigger":"rand.NewZipf",
            "contents":"rand.NewZipf(${1:r *Rand, s float64, v float64, imax uint64})",
            "details":"return  *Zipf",
            "annotation":"(r *Rand, s float64, v float64, imax uint64)"
        },
        {
            "trigger":"io.Copy",
            "contents":"io.Copy(${1:dst Writer, src Reader})",
            "details":"return  (written int64, err error)",
            "annotation":"(dst Writer, src Reader)"
        },
        {
            "trigger":"io.CopyBuffer",
            "contents":"io.CopyBuffer(${1:dst Writer, src Reader, buf []byte})",
            "details":"return  (written int64, err error)",
            "annotation":"(dst Writer, src Reader, buf []byte)"
        },
        {
            "trigger":"io.CopyN",
            "contents":"io.CopyN(${1:dst Writer, src Reader, n int64})",
            "details":"return  (written int64, err error)",
            "annotation":"(dst Writer, src Reader, n int64)"
        },
        {
            "trigger":"io.Pipe",
            "contents":"io.Pipe()",
            "details":"return  (*PipeReader, *PipeWriter)",
            "annotation":"()"
        },
        {
            "trigger":"io.ReadAll",
            "contents":"io.ReadAll(${1:r Reader})",
            "details":"return  ([]byte, error)",
            "annotation":"(r Reader)"
        },
        {
            "trigger":"io.ReadAtLeast",
            "contents":"io.ReadAtLeast(${1:r Reader, buf []byte, min int})",
            "details":"return  (n int, err error)",
            "annotation":"(r Reader, buf []byte, min int)"
        },
        {
            "trigger":"io.ReadFull",
            "contents":"io.ReadFull(${1:r Reader, buf []byte})",
            "details":"return  (n int, err error)",
            "annotation":"(r Reader, buf []byte)"
        },
        {
            "trigger":"io.WriteString",
            "contents":"io.WriteString(${1:w Writer, s string})",
            "details":"return  (n int, err error)",
            "annotation":"(w Writer, s string)"
        },
        {
            "trigger":"io.NewOffsetWriter",
            "contents":"io.NewOffsetWriter(${1:w WriterAt, off int64})",
            "details":"return  *OffsetWriter",
            "annotation":"(w WriterAt, off int64)"
        },
        {
            "trigger":"io.NopCloser",
            "contents":"io.NopCloser(${1:r Reader})",
            "details":"return  ReadCloser",
            "annotation":"(r Reader)"
        },
        {
            "trigger":"io.LimitReader",
            "contents":"io.LimitReader(${1:r Reader, n int64})",
            "details":"return  Reader",
            "annotation":"(r Reader, n int64)"
        },
        {
            "trigger":"io.MultiReader",
            "contents":"io.MultiReader(${1:readers ...Reader})",
            "details":"return  Reader",
            "annotation":"(readers ...Reader)"
        },
        {
            "trigger":"io.TeeReader",
            "contents":"io.TeeReader(${1:r Reader, w Writer})",
            "details":"return  Reader",
            "annotation":"(r Reader, w Writer)"
        },
        {
            "trigger":"io.NewSectionReader",
            "contents":"io.NewSectionReader(${1:r ReaderAt, off int64, n int64})",
            "details":"return  *SectionReader",
            "annotation":"(r ReaderAt, off int64, n int64)"
        },
        {
            "trigger":"io.MultiWriter",
            "contents":"io.MultiWriter(${1:writers ...Writer})",
            "details":"return  Writer",
            "annotation":"(writers ...Writer)"
        },
        {
            "trigger":"exec.LookPath",
            "contents":"exec.LookPath(${1:file string})",
            "details":"return  (string, error)",
            "annotation":"(file string)"
        },
        {
            "trigger":"exec.Command",
            "contents":"exec.Command(${1:name string, arg ...string})",
            "details":"return  *Cmd",
            "annotation":"(name string, arg ...string)"
        },
        {
            "trigger":"exec.CommandContext",
            "contents":"exec.CommandContext(${1:ctx context.Context, name string, arg ...string})",
            "details":"return  *Cmd",
            "annotation":"(ctx context.Context, name string, arg ...string)"
        },
        {
            "trigger":"sort.Find",
            "contents":"sort.Find(${1:n int, cmp func(int})",
            "details":"return  int) (i int, found bool)",
            "annotation":"(n int, cmp func(int)"
        },
        {
            "trigger":"sort.Float64s",
            "contents":"sort.Float64s(${1:x []float64})",
            "details":"return ",
            "annotation":"(x []float64)"
        },
        {
            "trigger":"sort.Float64sAreSorted",
            "contents":"sort.Float64sAreSorted(${1:x []float64})",
            "details":"return  bool",
            "annotation":"(x []float64)"
        },
        {
            "trigger":"sort.Ints",
            "contents":"sort.Ints(${1:x []int})",
            "details":"return ",
            "annotation":"(x []int)"
        },
        {
            "trigger":"sort.IntsAreSorted",
            "contents":"sort.IntsAreSorted(${1:x []int})",
            "details":"return  bool",
            "annotation":"(x []int)"
        },
        {
            "trigger":"sort.IsSorted",
            "contents":"sort.IsSorted(${1:data Interface})",
            "details":"return  bool",
            "annotation":"(data Interface)"
        },
        {
            "trigger":"sort.Search",
            "contents":"sort.Search(${1:n int, f func(int})",
            "details":"return  bool) int",
            "annotation":"(n int, f func(int)"
        },
        {
            "trigger":"sort.SearchFloat64s",
            "contents":"sort.SearchFloat64s(${1:a []float64, x float64})",
            "details":"return  int",
            "annotation":"(a []float64, x float64)"
        },
        {
            "trigger":"sort.SearchInts",
            "contents":"sort.SearchInts(${1:a []int, x int})",
            "details":"return  int",
            "annotation":"(a []int, x int)"
        },
        {
            "trigger":"sort.SearchStrings",
            "contents":"sort.SearchStrings(${1:a []string, x string})",
            "details":"return  int",
            "annotation":"(a []string, x string)"
        },
        {
            "trigger":"sort.Slice",
            "contents":"sort.Slice(${1:x any, less func(i, j int})",
            "details":"return  bool)",
            "annotation":"(x any, less func(i, j int)"
        },
        {
            "trigger":"sort.SliceIsSorted",
            "contents":"sort.SliceIsSorted(${1:x any, less func(i, j int})",
            "details":"return  bool) bool",
            "annotation":"(x any, less func(i, j int)"
        },
        {
            "trigger":"sort.SliceStable",
            "contents":"sort.SliceStable(${1:x any, less func(i, j int})",
            "details":"return  bool)",
            "annotation":"(x any, less func(i, j int)"
        },
        {
            "trigger":"sort.Sort",
            "contents":"sort.Sort(${1:data Interface})",
            "details":"return ",
            "annotation":"(data Interface)"
        },
        {
            "trigger":"sort.Stable",
            "contents":"sort.Stable(${1:data Interface})",
            "details":"return ",
            "annotation":"(data Interface)"
        },
        {
            "trigger":"sort.Strings",
            "contents":"sort.Strings(${1:x []string})",
            "details":"return ",
            "annotation":"(x []string)"
        },
        {
            "trigger":"sort.StringsAreSorted",
            "contents":"sort.StringsAreSorted(${1:x []string})",
            "details":"return  bool",
            "annotation":"(x []string)"
        },
        {
            "trigger":"sort.Reverse",
            "contents":"sort.Reverse(${1:data Interface})",
            "details":"return  Interface",
            "annotation":"(data Interface)"
        },
        {
            "trigger":"regexp.Match",
            "contents":"regexp.Match(${1:pattern string, b []byte})",
            "details":"return  (matched bool, err error)",
            "annotation":"(pattern string, b []byte)"
        },
        {
            "trigger":"regexp.MatchReader",
            "contents":"regexp.MatchReader(${1:pattern string, r io.RuneReader})",
            "details":"return  (matched bool, err error)",
            "annotation":"(pattern string, r io.RuneReader)"
        },
        {
            "trigger":"regexp.MatchString",
            "contents":"regexp.MatchString(${1:pattern string, s string})",
            "details":"return  (matched bool, err error)",
            "annotation":"(pattern string, s string)"
        },
        {
            "trigger":"regexp.QuoteMeta",
            "contents":"regexp.QuoteMeta(${1:s string})",
            "details":"return  string",
            "annotation":"(s string)"
        },
        {
            "trigger":"regexp.Compile",
            "contents":"regexp.Compile(${1:expr string})",
            "details":"return  (*Regexp, error)",
            "annotation":"(expr string)"
        },
        {
            "trigger":"regexp.CompilePOSIX",
            "contents":"regexp.CompilePOSIX(${1:expr string})",
            "details":"return  (*Regexp, error)",
            "annotation":"(expr string)"
        },
        {
            "trigger":"regexp.MustCompile",
            "contents":"regexp.MustCompile(${1:str string})",
            "details":"return  *Regexp",
            "annotation":"(str string)"
        },
        {
            "trigger":"regexp.MustCompilePOSIX",
            "contents":"regexp.MustCompilePOSIX(${1:str string})",
            "details":"return  *Regexp",
            "annotation":"(str string)"
        },
        {
            "trigger": "json.Compact",
            "contents": "json.Compact(${1:dst *bytes.Buffer, src []byte})",
            "details": "return  error",
            "annotation": "(dst *bytes.Buffer, src []byte)"
        },
        {
            "trigger": "json.HTMLEscape",
            "contents": "json.HTMLEscape(${1:dst *bytes.Buffer, src []byte})",
            "details": "return ",
            "annotation": "(dst *bytes.Buffer, src []byte)"
        },
        {
            "trigger": "json.Indent",
            "contents": "json.Indent(${1:dst *bytes.Buffer, src []byte, prefix, indent string})",
            "details": "return  error",
            "annotation": "(dst *bytes.Buffer, src []byte, prefix, indent string)"
        },
        {
            "trigger": "json.Marshal",
            "contents": "json.Marshal(${1:v any})",
            "details": "return  ([]byte, error)",
            "annotation": "(v any)"
        },
        {
            "trigger": "json.MarshalIndent",
            "contents": "json.MarshalIndent(${1:v any, prefix, indent string})",
            "details": "return  ([]byte, error)",
            "annotation": "(v any, prefix, indent string)"
        },
        {
            "trigger": "json.Unmarshal",
            "contents": "json.Unmarshal(${1:data []byte, v any})",
            "details": "return  error",
            "annotation": "(data []byte, v any)"
        },
        {
            "trigger": "json.Valid",
            "contents": "json.Valid(${1:data []byte})",
            "details": "return  bool",
            "annotation": "(data []byte)"
        },
        {
            "trigger": "json.NewDecoder",
            "contents": "json.NewDecoder(${1:r io.Reader})",
            "details": "return  *Decoder",
            "annotation": "(r io.Reader)"
        },
        {
            "trigger": "json.NewEncoder",
            "contents": "json.NewEncoder(${1:w io.Writer})",
            "details": "return  *Encoder",
            "annotation": "(w io.Writer)"
        },

        {
            "trigger": "http.CanonicalHeaderKey",
            "contents": "http.CanonicalHeaderKey(${1:s string})",
            "details": "return  string",
            "annotation": "(s string)"
        },
        {
            "trigger": "http.DetectContentType",
            "contents": "http.DetectContentType(${1:data []byte})",
            "details": "return  string",
            "annotation": "(data []byte)"
        },
        {
            "trigger": "http.Error",
            "contents": "http.Error(${1:w ResponseWriter, error string, code int})",
            "details": "return ",
            "annotation": "(w ResponseWriter, error string, code int)"
        },
        {
            "trigger": "http.Handle",
            "contents": "http.Handle(${1:pattern string, handler Handler})",
            "details": "return ",
            "annotation": "(pattern string, handler Handler)"
        },
        {
            "trigger": "http.HandleFunc",
            "contents": "http.HandleFunc(${1:pattern string, handler func(ResponseWriter, *Request})",
            "details": "return )",
            "annotation": "(pattern string, handler func(ResponseWriter, *Request)"
        },
        {
            "trigger": "http.ListenAndServe",
            "contents": "http.ListenAndServe(${1:addr string, handler Handler})",
            "details": "return  error",
            "annotation": "(addr string, handler Handler)"
        },
        {
            "trigger": "http.ListenAndServeTLS",
            "contents": "http.ListenAndServeTLS(${1:addr, certFile, keyFile string, handler Handler})",
            "details": "return  error",
            "annotation": "(addr, certFile, keyFile string, handler Handler)"
        },
        {
            "trigger": "http.MaxBytesReader",
            "contents": "http.MaxBytesReader(${1:w ResponseWriter, r io.ReadCloser, n int64})",
            "details": "return  io.ReadCloser",
            "annotation": "(w ResponseWriter, r io.ReadCloser, n int64)"
        },
        {
            "trigger": "http.NotFound",
            "contents": "http.NotFound(${1:w ResponseWriter, r *Request})",
            "details": "return ",
            "annotation": "(w ResponseWriter, r *Request)"
        },
        {
            "trigger": "http.ParseHTTPVersion",
            "contents": "http.ParseHTTPVersion(${1:vers string})",
            "details": "return  (major, minor int, ok bool)",
            "annotation": "(vers string)"
        },
        {
            "trigger": "http.ParseTime",
            "contents": "http.ParseTime(${1:text string})",
            "details": "return  (t time.Time, err error)",
            "annotation": "(text string)"
        },
        {
            "trigger": "http.ProxyFromEnvironment",
            "contents": "http.ProxyFromEnvironment(${1:req *Request})",
            "details": "return  (*url.URL, error)",
            "annotation": "(req *Request)"
        },
        {
            "trigger": "http.ProxyURL",
            "contents": "http.ProxyURL(${1:fixedURL *url.URL})",
            "details": "return  func(*Request) (*url.URL, error)",
            "annotation": "(fixedURL *url.URL)"
        },
        {
            "trigger": "http.Redirect",
            "contents": "http.Redirect(${1:w ResponseWriter, r *Request, url string, code int})",
            "details": "return ",
            "annotation": "(w ResponseWriter, r *Request, url string, code int)"
        },
        {
            "trigger": "http.Serve",
            "contents": "http.Serve(${1:l net.Listener, handler Handler})",
            "details": "return  error",
            "annotation": "(l net.Listener, handler Handler)"
        },
        {
            "trigger": "http.ServeContent",
            "contents": "http.ServeContent(${1:w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker})",
            "details": "return ",
            "annotation": "(w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)"
        },
        {
            "trigger": "http.ServeFile",
            "contents": "http.ServeFile(${1:w ResponseWriter, r *Request, name string})",
            "details": "return ",
            "annotation": "(w ResponseWriter, r *Request, name string)"
        },
        {
            "trigger": "http.ServeTLS",
            "contents": "http.ServeTLS(${1:l net.Listener, handler Handler, certFile, keyFile string})",
            "details": "return  error",
            "annotation": "(l net.Listener, handler Handler, certFile, keyFile string)"
        },
        {
            "trigger": "http.SetCookie",
            "contents": "http.SetCookie(${1:w ResponseWriter, cookie *Cookie})",
            "details": "return ",
            "annotation": "(w ResponseWriter, cookie *Cookie)"
        },
        {
            "trigger": "http.StatusText",
            "contents": "http.StatusText(${1:code int})",
            "details": "return  string",
            "annotation": "(code int)"
        },
        {
            "trigger": "http.FS",
            "contents": "http.FS(${1:fsys fs.FS})",
            "details": "return  FileSystem",
            "annotation": "(fsys fs.FS)"
        },
        {
            "trigger": "http.AllowQuerySemicolons",
            "contents": "http.AllowQuerySemicolons(${1:h Handler})",
            "details": "return  Handler",
            "annotation": "(h Handler)"
        },
        {
            "trigger": "http.FileServer",
            "contents": "http.FileServer(${1:root FileSystem})",
            "details": "return  Handler",
            "annotation": "(root FileSystem)"
        },
        {
            "trigger": "http.MaxBytesHandler",
            "contents": "http.MaxBytesHandler(${1:h Handler, n int64})",
            "details": "return  Handler",
            "annotation": "(h Handler, n int64)"
        },
        {
            "trigger": "http.NotFoundHandler",
            "contents": "http.NotFoundHandler()",
            "details": "return  Handler",
            "annotation": "()"
        },
        {
            "trigger": "http.RedirectHandler",
            "contents": "http.RedirectHandler(${1:url string, code int})",
            "details": "return  Handler",
            "annotation": "(url string, code int)"
        },
        {
            "trigger": "http.StripPrefix",
            "contents": "http.StripPrefix(${1:prefix string, h Handler})",
            "details": "return  Handler",
            "annotation": "(prefix string, h Handler)"
        },
        {
            "trigger": "http.TimeoutHandler",
            "contents": "http.TimeoutHandler(${1:h Handler, dt time.Duration, msg string})",
            "details": "return  Handler",
            "annotation": "(h Handler, dt time.Duration, msg string)"
        },
        {
            "trigger": "http.NewRequest",
            "contents": "http.NewRequest(${1:method, url string, body io.Reader})",
            "details": "return  (*Request, error)",
            "annotation": "(method, url string, body io.Reader)"
        },
        {
            "trigger": "http.NewRequestWithContext",
            "contents": "http.NewRequestWithContext(${1:ctx context.Context, method, url string, body io.Reader})",
            "details": "return  (*Request, error)",
            "annotation": "(ctx context.Context, method, url string, body io.Reader)"
        },
        {
            "trigger": "http.ReadRequest",
            "contents": "http.ReadRequest(${1:b *bufio.Reader})",
            "details": "return  (*Request, error)",
            "annotation": "(b *bufio.Reader)"
        },
        {
            "trigger": "http.Get",
            "contents": "http.Get(${1:url string})",
            "details": "return  (resp *Response, err error)",
            "annotation": "(url string)"
        },
        {
            "trigger": "http.Head",
            "contents": "http.Head(${1:url string})",
            "details": "return  (resp *Response, err error)",
            "annotation": "(url string)"
        },
        {
            "trigger": "http.Post",
            "contents": "http.Post(${1:url, contentType string, body io.Reader})",
            "details": "return  (resp *Response, err error)",
            "annotation": "(url, contentType string, body io.Reader)"
        },
        {
            "trigger": "http.PostForm",
            "contents": "http.PostForm(${1:url string, data url.Values})",
            "details": "return  (resp *Response, err error)",
            "annotation": "(url string, data url.Values)"
        },
        {
            "trigger": "http.ReadResponse",
            "contents": "http.ReadResponse(${1:r *bufio.Reader, req *Request})",
            "details": "return  (*Response, error)",
            "annotation": "(r *bufio.Reader, req *Request)"
        },
        {
            "trigger": "http.NewResponseController",
            "contents": "http.NewResponseController(${1:rw ResponseWriter})",
            "details": "return  *ResponseController",
            "annotation": "(rw ResponseWriter)"
        },
        {
            "trigger": "http.NewFileTransport",
            "contents": "http.NewFileTransport(${1:fs FileSystem})",
            "details": "return  RoundTripper",
            "annotation": "(fs FileSystem)"
        },
        {
            "trigger": "http.NewServeMux",
            "contents": "http.NewServeMux()",
            "details": "return  *ServeMux",
            "annotation": "()"
        },

        {
            "trigger": "log.Fatal",
            "contents": "log.Fatal(${1:v ...any})",
            "details": "return ",
            "annotation": "(v ...any)"
        },
        {
            "trigger": "log.Fatalf",
            "contents": "log.Fatalf(${1:format string, v ...any})",
            "details": "return ",
            "annotation": "(format string, v ...any)"
        },
        {
            "trigger": "log.Fatalln",
            "contents": "log.Fatalln(${1:v ...any})",
            "details": "return ",
            "annotation": "(v ...any)"
        },
        {
            "trigger": "log.Flags",
            "contents": "log.Flags()",
            "details": "return  int",
            "annotation": "()"
        },
        {
            "trigger": "log.Output",
            "contents": "log.Output(${1:calldepth int, s string})",
            "details": "return  error",
            "annotation": "(calldepth int, s string)"
        },
        {
            "trigger": "log.Panic",
            "contents": "log.Panic(${1:v ...any})",
            "details": "return ",
            "annotation": "(v ...any)"
        },
        {
            "trigger": "log.Panicf",
            "contents": "log.Panicf(${1:format string, v ...any})",
            "details": "return ",
            "annotation": "(format string, v ...any)"
        },
        {
            "trigger": "log.Panicln",
            "contents": "log.Panicln(${1:v ...any})",
            "details": "return ",
            "annotation": "(v ...any)"
        },
        {
            "trigger": "log.Prefix",
            "contents": "log.Prefix()",
            "details": "return  string",
            "annotation": "()"
        },
        {
            "trigger": "log.Print",
            "contents": "log.Print(${1:v ...any})",
            "details": "return ",
            "annotation": "(v ...any)"
        },
        {
            "trigger": "log.Printf",
            "contents": "log.Printf(${1:format string, v ...any})",
            "details": "return ",
            "annotation": "(format string, v ...any)"
        },
        {
            "trigger": "log.Println",
            "contents": "log.Println(${1:v ...any})",
            "details": "return ",
            "annotation": "(v ...any)"
        },
        {
            "trigger": "log.SetFlags",
            "contents": "log.SetFlags(${1:flag int})",
            "details": "return ",
            "annotation": "(flag int)"
        },
        {
            "trigger": "log.SetOutput",
            "contents": "log.SetOutput(${1:w io.Writer})",
            "details": "return ",
            "annotation": "(w io.Writer)"
        },
        {
            "trigger": "log.SetPrefix",
            "contents": "log.SetPrefix(${1:prefix string})",
            "details": "return ",
            "annotation": "(prefix string)"
        },
        {
            "trigger": "log.Writer",
            "contents": "log.Writer()",
            "details": "return  io.Writer",
            "annotation": "()"
        },
        {
            "trigger": "log.Default",
            "contents": "log.Default()",
            "details": "return  *Logger",
            "annotation": "()"
        },
        {
            "trigger": "log.New",
            "contents": "log.New(${1:out io.Writer, prefix string, flag int})",
            "details": "return  *Logger",
            "annotation": "(out io.Writer, prefix string, flag int)"
        },

        {
            "trigger": "regexp.Match",
            "contents": "regexp.Match(${1:pattern string, b []byte})",
            "details": "return  (matched bool, err error)",
            "annotation": "(pattern string, b []byte)"
        },
        {
            "trigger": "regexp.MatchReader",
            "contents": "regexp.MatchReader(${1:pattern string, r io.RuneReader})",
            "details": "return  (matched bool, err error)",
            "annotation": "(pattern string, r io.RuneReader)"
        },
        {
            "trigger": "regexp.MatchString",
            "contents": "regexp.MatchString(${1:pattern string, s string})",
            "details": "return  (matched bool, err error)",
            "annotation": "(pattern string, s string)"
        },
        {
            "trigger": "regexp.QuoteMeta",
            "contents": "regexp.QuoteMeta(${1:s string})",
            "details": "return  string",
            "annotation": "(s string)"
        },
        {
            "trigger": "regexp.Compile",
            "contents": "regexp.Compile(${1:expr string})",
            "details": "return  (*Regexp, error)",
            "annotation": "(expr string)"
        },
        {
            "trigger": "regexp.CompilePOSIX",
            "contents": "regexp.CompilePOSIX(${1:expr string})",
            "details": "return  (*Regexp, error)",
            "annotation": "(expr string)"
        },
        {
            "trigger": "regexp.MustCompile",
            "contents": "regexp.MustCompile(${1:str string})",
            "details": "return  *Regexp",
            "annotation": "(str string)"
        },
        {
            "trigger": "regexp.MustCompilePOSIX",
            "contents": "regexp.MustCompilePOSIX(${1:str string})",
            "details": "return  *Regexp",
            "annotation": "(str string)"
        },
    ]
}